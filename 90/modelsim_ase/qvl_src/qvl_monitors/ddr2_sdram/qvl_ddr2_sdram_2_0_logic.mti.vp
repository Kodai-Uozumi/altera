//              Copyright 2006-2007 Mentor Graphics Corporation
//                           All Rights Reserved.
//
//              THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY
//            INFORMATION WHICH IS THE PROPERTY OF MENTOR GRAPHICS
//           CORPORATION OR ITS LICENSORS AND IS SUBJECT TO LICENSE
//                                  TERMS.
//
//                   Questa Verification Library (QVL)
//

/*************************************************************************
 *
 * PURPOSE      This file is part of 0-In CheckerWare.
 *              It describes the DDR2 SDRAM monitor.
 *
 * REFERENCE    JESD79-2 DDR2 SDRAM Specification,
 *              JEDEC Solid State Technology Association, September 2003
 *
 * DESCRIPTION  This monitor checks if the DDR2 SDRAM memory interface 
 *              functions properly.
 *
 * INPUTS       areset       - Asynchronous reset.
 *              reset        - Synchronous reset.
 *              ck           - Input differential clock.
 *              ck_n         - Input differential clock.
 *              cke          - Clock Enable. 
 *              cs_n         - Chip Select. 
 *              ras_n        - Row Address Strobe.   
 *              cas_n        - Column Address Strobe. 
 *              we_n         - Write Enable. 
 *              dm_rdqs      - Data Mask / Read data strobe (only in x8 mode).
 *              ba           - Bank Address.
 *              a            - Address bus. 
 *              dq           - Data bus - {D7:D0} - used for x4 and x8 modes.
 *              dqs          - Data Strobe for port "dq".
 *              ldqs         - Data Strobe for port "ldq".
 *              ldm          - Data Mask for port "ldq".
 *              udqs         - Data Strobe for port "udq".
 *              udm          - Data Mask for port "udq".
 *              mode_register_in - Mode register input.
 *              ex_mode_register_in - Extended mode register input.
 *
 * 
 * USAGE        The monitor should be instantiated as shown below:
 *
 *
 *            +---------------+                          +---------------+
 *            |               |---        ck          -->|               | 
 *            | +-----------+ |---        ck_n        -->|               | 
 *            | |DDR2 SDRAM | |---        cke         -->|  DDR2 SDRAM   | 
 *            | |Monitor    | |---        cs_n        -->|               | 
 *            | +-----------+ |---        ras_n       -->|               | 
 *            |               |---        cas_n       -->|               | 
 *            |               |---        we_n        -->|               | 
 *            | DDR2 SDRAM    |---        dm_rdqs     -->|               | 
 *            | Controller    |---        ba          -->|               | 
 *            |               |---        a           -->|               | 
 *            |               |<--        dq          -->|               | 
 *            |               |<--        dqs         -->|               | 
 *            |               |<--        ldq         -->|               | 
 *            |               |<--        ldqs        -->|               |
 *            |               |<--        ldm         -->|               |
 *            |               |<--        udq         -->|               |
 *            |               |<--        udqs        -->|               |
 *            |               |<--        udm         -->|               |
 *            |               |<-- mode_register_in   -->|               |
 *            |               |<- ex_mode_register_in -->|               |
 *            |               |                          |               |
 *            +---------------+                          +---------------+
 *
 *                                        (OR)
 *
 *            +---------------+                          +---------------+
 *            |               |---        ck          -->|               | 
 *            |               |---        ck_n        -->|               | 
 *            |               |---        cke         -->|  DDR2 SDRAM   | 
 *            |               |---        cs_n        -->|               | 
 *            | DDR2 SDRAM    |---        ras_n       -->|               | 
 *            | Controller    |---        cas_n       -->|               | 
 *            |               |---        we_n        -->|               | 
 *            |               |---        dm_rdqs     -->| +-----------+ |
 *            |               |---        ba          -->| |DDR2 SDRAM | | 
 *            |               |---        a           -->| |Monitor    | |
 *            |               |<--        dq          -->| +-----------+ |
 *            |               |<--        dqs         -->|               | 
 *            |               |<--        ldq         -->|               | 
 *            |               |<--        ldqs        -->|               | 
 *            |               |<--        ldm         -->|               | 
 *            |               |<--        udq         -->|               | 
 *            |               |<--        udqs        -->|               | 
 *            |               |<--        udm         -->|               | 
 *            |               |<-- mode_register_in   -->|               |
 *            |               |<- ex_mode_register_in -->|               |
 *            |               |                          |               |
 *            +---------------+                          +---------------+
 *
 * LAST MODIFIED : 06 April 2006.
 *
 **************************************************************************/

`ifdef ZiCwDebug
 `define ZiCwDebugDelay1 #1
`else
 `define ZiCwDebugDelay1
`endif //ZiCwDebug


`ifdef QVL_COVER_ON
  `ifdef QVL_SV_COVERGROUP_OFF
    // Do nothing
  `else
    `define QVL_SV_COVERGROUP
  `endif
  `ifdef QVL_MW_FINAL_COVER_OFF
    // Do nothing
  `else
    `define QVL_MW_FINAL_COVER
  `endif
`endif

`qvlmodule qvl_ddr2_sdram_2_0_logic (ck,
				 ck_n,
				 areset,
				 reset,
				 cke,
				 cs_n,
				 ras_n, 
				 cas_n,
				 we_n,
				 dm_rdqs,
				 ba,
				 a,
				 dq,
				 dqs,
				 ldqs,
				 ldm,
				 udqs,
				 udm,
				 mode_register_in,
				 ex_mode_register_in
                                );

  parameter Constraints_Mode = 0; // 0in constraint
  wire [31:0] pw_Constraints_Mode = Constraints_Mode;

  parameter CONTROLLER_SIDE = 1; // 1 implies monitor is instantiated on the
                                 // controller side. else memory side  
  wire [31:0] pw_CONTROLLER_SIDE = CONTROLLER_SIDE;

  parameter ROW_ADDR_WIDTH = 16; // Size of address bus equals row_addr_width
  wire [31:0] pw_ROW_ADDR_WIDTH = ROW_ADDR_WIDTH;

  parameter DATA_BUS_WIDTH = 8; // Width of the Data Bus configuration
  wire [31:0] pw_DATA_BUS_WIDTH = DATA_BUS_WIDTH;

  parameter DLL_TRACKING_ENABLE = 1;
  wire [31:0] pw_DLL_TRACKING_ENABLE = DLL_TRACKING_ENABLE;

  parameter TRAS = 6; // Active to precharge command
  wire [31:0] pw_TRAS = TRAS;

  parameter TRCD = 2; // Active to read/write delay
  wire [31:0] pw_TRCD = TRCD;

  parameter TRP = 2; // Precharge command period
  wire [31:0] pw_TRP = TRP;

  parameter TRRD = 1; // Bank A activate to bank B activate
  wire [31:0] pw_TRRD = TRRD;

  parameter TCCD = 2; // CAS A to CAS B delay
  wire [31:0] pw_TCCD = TCCD;

  parameter TRTW = 4; // Read to write turnaround time
  wire [31:0] pw_TRTW = TRTW;

  parameter TWTR = 1; // Write to read turnaround time
  wire [31:0] pw_TWTR = TWTR;

  parameter TWR = 2; // Write recovery time
  wire [31:0] pw_TWR = TWR;

  parameter TRFC = 9; // Auto-refresh to auto-refresh or activation period
  wire [31:0] pw_TRFC = TRFC;

  parameter TXSNR = 10; // Exit self-refresh to a non-read command delay
  wire [31:0] pw_TXSNR = TXSNR;

  parameter TXSRD = 200; // Exit self-refresh to a read command delay
  wire [31:0] pw_TXSRD = TXSRD;

  parameter TMRD = 2; // Mode register set command cycle time
  wire [31:0] pw_TMRD = TMRD;

  parameter  AUTOPRECHARGE_ENABLE_ADDRESS_BIT = 10;
  wire [31:0] pw_AUTOPRECHARGE_ENABLE_ADDRESS_BIT =
              AUTOPRECHARGE_ENABLE_ADDRESS_BIT;

  //The following parameter is used to enable/disable the
  //read before write checker.

  parameter  READ_BEFORE_WRITE_CHECK_ENABLE = 1;
  wire [31:0] pw_READ_BEFORE_WRITE_CHECK_ENABLE =
              READ_BEFORE_WRITE_CHECK_ENABLE;

  // The following parameters added to verify the power down exit 
  // latencies for non read and read commands
  
  parameter TXP = 2; // Precharge power down to non read command time 
  wire [31:0] pw_TXP = TXP;
  
  parameter TXARD = 2; // Active power down to read command, fast exit 
  wire [31:0] pw_TXARD = TXARD;
 
  // The following parameter defines the width of the bank address
  parameter BANK_ADDR_WIDTH = 3;
  wire [31:0] pw_BANK_ADDR_WIDTH = BANK_ADDR_WIDTH;

  parameter ENABLE_PRECHARGE_TO_IDLE_BANK = 0;
  wire [31:0] pw_ENABLE_PRECHARGE_TO_IDLE_BANK = ENABLE_PRECHARGE_TO_IDLE_BANK;

  parameter BYPASS_INIT = 0;
  wire [31:0] pw_BYPASS_INIT = BYPASS_INIT;

  // Use the following parameter to configure the monitor to support the new 
  // DDR2 SDRAM specification (1.0) of September 2003
  parameter ZI_DDR2_SDRAM_2_0 = 1;
  wire [31:0] pw_DDR2_SDRAM_2_0 = ZI_DDR2_SDRAM_2_0;

  //The following parameter is used to enable/disable the
  //data checker.
  parameter  ZI_DATA_CHECK_ENABLE = 1;
  wire [31:0] pw_DATA_CHECK_ENABLE = ZI_DATA_CHECK_ENABLE;

  // The following parameter is used to define the width of the DM bus. This 
  // is used only if the monitor is operated in place of the old version, which
  // allows fully configurable data bus width and thereby the data mask bus.
  parameter ZI_DM_WIDTH = 1;
  wire [31:0] pw_DM_WIDTH = ZI_DM_WIDTH;

  parameter ZI_DATA_PORT_SIZE = 8;
  wire [31:0] pw_DATA_PORT_SIZE = ZI_DATA_PORT_SIZE;

  // The following parameter defines the width of the mode register
  parameter ZI_MODE_REG_WIDTH = ROW_ADDR_WIDTH + BANK_ADDR_WIDTH;
  wire [31:0] pw_MODE_REG_WIDTH = ZI_MODE_REG_WIDTH;

  // The following parameter defines the width of the dm port, which is used 
  // only if the DM is used as a bus, in case of old version of the monitor.
  parameter ZI_DM_RDQS_WIDTH = (ZI_DDR2_SDRAM_2_0 === 1) ? 1 : ZI_DM_WIDTH;

  parameter QVL_TCKE = 3;
 
  input ck;
  input ck_n;
  input areset; 
  input reset;
  input cke;
  input cs_n;
  input ras_n; 
  input cas_n; 
  input we_n;
  input [ZI_DM_RDQS_WIDTH-1:0] dm_rdqs;
  input [BANK_ADDR_WIDTH-1:0] ba;
  input [ROW_ADDR_WIDTH-1:0] a;
  input [DATA_BUS_WIDTH-1:0] dq; 
  input dqs;
  input ldqs;
  input ldm;
  input udqs;
  input udm;
  input [ZI_MODE_REG_WIDTH-1:0] mode_register_in;
  input [ZI_MODE_REG_WIDTH-1:0] ex_mode_register_in;

  parameter ZI_INT_DM_WIDTH = (ZI_DDR2_SDRAM_2_0 === 0) ? ZI_DM_WIDTH :
			     (DATA_BUS_WIDTH <= 8) ? 1 : (DATA_BUS_WIDTH >> 3);
  wire [31:0] pw_INT_DM_WIDTH = ZI_INT_DM_WIDTH;

  parameter ZI_CONSTRAINTS_MEMORY_SIDE = (Constraints_Mode === 1 &&
                                          CONTROLLER_SIDE === 0);
  wire [31:0] pw_ZI_CONSTRAINTS_MEMORY_SIDE = ZI_CONSTRAINTS_MEMORY_SIDE;

  // The following parameter indicates the minimum interval required between 
  // a DLL reset and the first read command
  parameter ZI_TDLL_RST_RD = 200;
  wire [31:0] pw_ZI_TDLL_RST_RD = ZI_TDLL_RST_RD;

  // Wires included as replacement for the ports ldq and udq

  wire [ZI_DATA_PORT_SIZE-1:0] ldq; 
  wire [ZI_DATA_PORT_SIZE-1:0] udq;

  // Mode register width declared using parameter 
  // This holds burst_type, cas_latency, mode info

  reg [ZI_MODE_REG_WIDTH-1:0] mode_register; 
  reg [ZI_MODE_REG_WIDTH-1:0] mode_register_input;
  reg mode_reg_set; // To be programmed at initialization time

  // Mode register width declared using parameter
  // This holds additve latency etc that is to be programmed at initialization

  reg [ZI_MODE_REG_WIDTH-1:0] ex_mode_register; 
  reg [ZI_MODE_REG_WIDTH-1:0] ex_mode_register_input;
  reg ex_mode_reg_set; // programmed during initialization sequence
  reg r_cke; // Registered CKE

  wire [2:0] cas_latency = (BYPASS_INIT === 0) ? mode_register[6:4] : 
						 mode_register_input[6:4];
  wire burst_type = (BYPASS_INIT === 0) ? mode_register[3] :
					  mode_register_input[3];
  wire [2:0] additive_latency = (BYPASS_INIT === 0) ? ex_mode_register[5:3] :
						ex_mode_register_input[5:3];

  // tWR, burst length, operating mode tappings from mode register
  wire [2:0] tWR_programmed = (ZI_DDR2_SDRAM_2_0 === 0) ? 0 : 
			      (BYPASS_INIT === 0) ? mode_register[11:9] + 1'b1 :
						    mode_register_input[11:9] +1'b1;
  wire [2:0] burst_length_programmed = (BYPASS_INIT === 0) ? mode_register[2:0]
						  : mode_register_input[2:0];
  wire operating_mode = (ZI_DDR2_SDRAM_2_0 === 0) ?  0 : (BYPASS_INIT === 0) ? 
			 mode_register[7] : mode_register_input[7];
  wire slow_exit = (ZI_DDR2_SDRAM_2_0 === 0) ? 0 : (BYPASS_INIT === 0) ? 
		    mode_register[12] : mode_register_input[12];
  wire rdqs_enable = (ZI_DDR2_SDRAM_2_0 === 0) ? 0 : (BYPASS_INIT === 0) ? 
		                       (ex_mode_register[11] === 1'b1) :
				       (ex_mode_register_input[11] === 1'b1);
  wire diff_strobe_enable = (ZI_DDR2_SDRAM_2_0 === 0) ? 0 : 
			    (BYPASS_INIT === 0) ? 
       (ex_mode_register[10] === 1'b0) : (ex_mode_register_input[10] === 1'b0);

  wire rdqs = (DATA_BUS_WIDTH === 8 && rdqs_enable === 1'b1) ? dm_rdqs : 1'b0;

  // This section contains declarations or wires used as commands for the
  // DDR2 SDRAM bankm module. The input to the module 'command' holds the
  // values of CKE, CKE_last, CS#, RAS#, CAS# and WE#. These control lines 
  // decide the command issued by the controller. This encoding is compliant
  // with the truth table 3.1 in page 35 of the reference mentioned.
  
  wire [5:0] command = {r_cke,cke,cs_n,ras_n,cas_n,we_n};
 
  wire z_mode_reg_set_cmd = (command === 6'b110000 && ba[1:0] === 2'b00);
  wire z_ex_mode_reg_set_cmd = (command === 6'b110000 && ba[1:0] === 2'b01);

  // z_ex_mode_reg_2_set_cmd and z_ex_mode_reg_3_set_cmd defined
  wire z_ex_mode_reg_2_set_cmd = (command === 6'b110000 && ba[1:0] === 2'b10);
  wire z_ex_mode_reg_3_set_cmd = (command === 6'b110000 && ba[1:0] === 2'b11);

  wire z_precharge_all_cmd = (command === 6'b110010 && 
                              a[AUTOPRECHARGE_ENABLE_ADDRESS_BIT] === 1'b1);
  wire z_precharge_cmd = (command === 6'b110010 && 
                              a[AUTOPRECHARGE_ENABLE_ADDRESS_BIT] === 1'b0);
  wire z_activate_cmd = (command === 6'b110011);
  wire z_write_cmd = (command === 6'b110100 && 
                              a[AUTOPRECHARGE_ENABLE_ADDRESS_BIT] === 1'b0);
  wire z_write_auto_precharge_cmd = (command === 6'b110100 && 
                              a[AUTOPRECHARGE_ENABLE_ADDRESS_BIT] === 1'b1);
  wire z_read_cmd = (command === 6'b110101 && 
                              a[AUTOPRECHARGE_ENABLE_ADDRESS_BIT] === 1'b0);
  wire z_read_auto_precharge_cmd = (command === 6'b110101 && 
                              a[AUTOPRECHARGE_ENABLE_ADDRESS_BIT] === 1'b1);
  wire z_cbr_auto_refresh_cmd = (command === 6'b110001);
  wire z_enter_self_refresh_cmd = (command === 6'b100001);
  wire z_exit_self_refresh_cmd = (command[5:3] === 3'b011 || 
                                  command === 6'b010111);
  wire z_enter_power_down_cmd = (command === 6'b100111 || 
				   command[5:3] === 3'b101);
  wire z_exit_power_down_cmd = (command[5:3] === 3'b011 ||
                               command === 6'b010111);
  wire z_nop_cmd = (command === 6'b110111);
  wire z_deselect_cmd = (command[3] === 1'b1);

  // wire declarations for individual bank status

  wire bank_0_status;  // these are inputs from each of the bank modules
  wire bank_1_status;  // each bank module passes its current state to the
  wire bank_2_status;  // main mudlue through these.
  wire bank_3_status;

  // status inputs from four new banks.

  wire bank_4_status;
  wire bank_5_status;
  wire bank_6_status;
  wire bank_7_status;
 
  // redefined num_banks_active

  wire [3:0] num_banks_active;

  // Checks block

  reg [7:0] auto_refresh_cmd_ctr;
  reg all_banks_in_precharge;
  reg dll_enabled;
  reg dll_reset;
  reg [2:0] cas_latency_value;
  reg tRRD_violation;
  reg [2:0] prev_bank_addr; 
  reg [7:0] track_tRRD_counter;
  reg parameter_checks_active;
  reg z_valid_clock_detected;
  reg [7:0] dll_reset_to_first_read_counter;
  reg r_dll_reset;
  reg first_read_command;
  reg r_first_read_command;
  reg emrs_2_cmd_issued;
  reg emrs_3_cmd_issued;
  reg first_pre_all_cmd_recd;
  reg first_activation_command;

  integer i;

  // Sequential activation window - this effectively holds 
  // info abt all commands during the last (4*tRRD + 2tCK) clocks, on whether
  // each command was an activation command or not. This is used to check 
  // whether there were more than 4 ACT commands issued in any (4*tRRD + 2tCK)
  // window over the entire simulation.

  reg [(((4*TRRD)+2)-1):0] sliding_activation_window;
  reg [7:0] sum_of_acts_over_last_window;

  reg [7:0] bank_ck_enable;
  reg [7:0] bank_ck_n_enable;
  reg [QVL_TCKE-1:0] cke_pipe;

  // Wires used for check enables

  wire mrs_during_non_precharge;
  wire emrs_during_non_precharge;
  wire auto_during_non_precharge;
  wire selfref_during_non_precharge;
  wire insufficient_autorefs_before_active;
  wire modereg_not_set_before_active;
  wire dll_not_reset_before_active;
  wire emrs_2_not_issued_before_emrs_3;
  wire emrs_3_not_issued_before_emrs;
  wire sequential_activation_violation;
  wire cas_latency_invalid;
  wire additive_latency_invalid;
  wire illegal_cmd_before_mrs;
  wire mrs_programmed_correctly;
  wire cas_latency_invalid_bypass;
  wire additive_latency_invalid_bypass;
  wire mrs_programmed_correctly_bypass; 
  wire tdll_reset_violation;

`protected

    MTI!#y><<!Zr>Dn_o=2HVZG>xGQE's{T\~s,z[8oe[[ImY<=ZomnhOnQ?BHovDBEBi[$O_Yn,$x+
    A7iP<7i[2=-{mjR!X''1>7'BY(iY+]7\;?A[e@bn>H7V,u5P2'\*[^'+~wREG;X!~a'D>xW3*awC
    RKpR9dOK}[UwZTFp?WIc%-'*<P*In?7\Q3@UmnsA<#[*0ZhGCA$3x'~'Q]?Noxkar,$]Q!Y'2s]e
    "e@H7p-lVN_zXYw{=;>|$p;ZGW$BQ'?VslrG*HA2=a~_zVm=5xOD{V,~7Zx}]rnk=I\{t*Drp7?5
    1ylZ*m#U!l7R?Wx-nOo#Oal!,7,pr35e?@}D3ZKYK]4**pR&<5B<=Y~G#s+sWw^!F<v7@\*BB!];
    +QzxuBl$~5[[v{&,]'-~_71$r?xiCJGn12Cg=#1C*O'u<1mH3,upKr$U[;7XPkXuBemW[Tp3oB~T
    uRWEOJD[WFx1K}uE'OH[Ba,'!XYDmrGaBoG=,+Bi,W6YjXeC=-wAVp?=w,?7k\rV;~]xO!]\R}3x
    l#EXejpeC*$=A}5C2>>\]=#Q|2AAROvA$R]e,R!<Ho]_*}<A[WC]7l3+,Wt>$l3\^-X[QC5{U{$_
    !Vuz3ZrXC[<+VU=2'R[I@VXEV$3.*pI1'W1oxOz[5WxC-}V{z^2$7D*CzVRk*[=+BZU}U>H#C2uD
    ]\2=.xo2T-rH#R-H{r[zwC[#C$&=Z17k>T#kG[X@wpeJX2@$A<25aA7<]pi,Zw#y,-nuN0'rZn#C
    zH
`endprotected

`protected

    MTI!#<e?'vv5EqbxZ$GB}#TT$IG(i*7'-7!OF:iwb[k}<7~![N.7u,3}#}^k5@-<EZ_+OKoJ\3[\
    lKY'K3+[ovZ!5#pz=a5j[G,[Tnj=!T[$Xn2wr1o1^ReV1ET;_oaDGkei+zY#OA][V]W_A*]~+<Og
    r2aTbw_3aXX3GL/\j3$=5k=n$eBb!eBI.%%+]~p,OGQZ1JHA*s'o$XZG3^!\e}RHs}O79rmCT!aE
    v?7+}3Az]D2V{RuvO\xme36Ko,*73m</QQxwe@Cr[T7+k5;_t'3B_@'ZVja\k5YGWQ'Z=JX_Ur>$
    el2-*@E=_kwuUQIJ^]uDez?$$KQ3V~AgxC7nsaC3m=Z7-EU#\27HPk_R<AUwC\,<*)7TXD37EG{X
    wTwwKJsY_~$pvkpOouY_A=Z77?e_,uv~n_[1B5RXpQ*{vDE(~H2}}V>#8n*T]r5YJVx\JC2Ks3I?
    ]TQp*RO+5!EujB<^{_O5o[^<zHB~_jY!KD1*}TV5vGI1]VD-A1w~a]Q?kCU<xlmmz+DCrEYZ^}w]
    j*l\;[vHJ.n]n>CUvmA{w~b-Q;++^kpk}ujEO*E-TD=e_Jnz**n'j<7kH!*KEY1kOh^A'~5HJ<iU
    v-1G[uB;qnTm~~\s]EC~A>'Q-NkTo\U'1$DA\[JXz@Kal1srKH|Y[-Gl}!7'W1\$w*CN~+IKT|(\
    nu1$IeKW{+VkwpG7]v,K$#Vz=z*_^e}DYz-\@3v<w7lG7E3xoCJQ2+IF2Ij$$J$i?1IHa'I]Y\uw
    bl,mVl#I'CzJU37DVD?KA2=[vesB!n=CQlq3[m>31p[HI3UB_jU3Om5[GuIV#3~om'Z7DJwQuvn_
    AH@}e{$7OlpYVX[?D3kn$#pa\tH'-p.}Uul73Vn~<]#_rTTA$#JuV\Al5+J2_-Qx\n>7<1_aXQH3
    pr2B_j~V;A@6$iVHRiHpZ7]=RuDT5w<jk>u>n>!kWl-v}EkR|=~CQ#5-,-EI+V@b:(rVzAs-ETwD
    5E<H+QKj-!3I;z@<elcEkBvE>A,DV#aeT@zx!BJQOe1CGz'Do+]ZAaT|'#{C!$<}17<[O1mxxp$m
    :{U2ng^nHAIx}uEYz#CKxjEClZk5@k_R_G+XO_Qoo[VXuxP_Hr{o^aDBWl2+E\~s~+Q$rGVDD<7w
    Bu*Qx-ajCjwF<I}J]BZA@rEK\Ca37,I=={[{$Qj?}i=[w>{OVne]*=$Yxuv@o{5k0IZ<eX^T~?Dx
    akV3e0l3mjj"&--Y<e,moK_-HI'[T$xwk^K,xoC_3ps*-,A~[5%99m,@IJ=rGF{=J>C[U#Ko-5j*
    }$K<lQY7XAA{C3'IZmZCvx{Dk2\I7vz;2;N$_#vxmKjHx<pe%)"UrsmC'CK1am*rx@!@o@~C+@,x
    +A}K=T[!In~k1l=Bj?WW'{'^KU'8nE!uz5\_'*G}1KAHG3I$JCjB{[[m)fKQw~Ms@3A^#>w+BzHH
    9lABo>7<v^$![~[-T\k$nj2X2><1m+AYi]BBmY?CH'@J$\3HCIOj5iAYnIu+[u[2wXsxa*#1;E2x
    +Lj*>KVA>=E}@}DB+k5$D^vlE?v\w5i<{T#'CHinp>u]A3paVjJjeuWUH3};xIn1k=H$5$AEJ_+o
    jo>D-p}B=v17xmzZo,'CA*oT,^I33r$]?1kE}C{R"E^$#xxs]sXJJka!J*3$woz3'K$?Ke-4xW@+
    IK@^W'"TxXv@e#aBWA$]DpoF?s\nj}UjgZYux;G?3i,{\q}Z[s]7~DXj>BQ[=iXAU}5J\Bk}yY?x
    nvrH-5]os*m$=};~rIas}<-lj{}EU0w&?SnDBz$@AW%/\}^Ay2vz]cTr$[*zo$*-EZ#7?T]~-D7V
    =5IQ1K1ZZ]3\~};CpH>,X,s]{G1X,v5Bzp%fxv#HG<>E]}#_&0_#p]oiBl_w+~=\UsjU3va>$rCI
    AT=D!T+r7C[@RY_u\^s21r\X_s$O-\<H73_v,G2H'\~V]i_7[p_'A2_m_BGGB{,'5DZQ3H@9-$\i
    zU~*xnW!'BXIB$s'GAw]HxVzwpZTI2{Cte}E1\Y}5oKGl|V5{BK{'ZFEJRsCM_T2?=Ojk*>AV<RO
    iwvajI(7-sY}[m_p@Bo.f*v@<^H^xo^J}=lD++<'i[mv^iD#n~-v*l<.Ii$zem;CUB]nXT<'7}V=
    cD<BE#_3ZVHpWkA7G=[]j,(1_DK'D7B_aa-p?Y?/\^H?Q^{o=KzDsiYa:x$>#aB_Dm]]UXxDi8l!
    ];3YUmavX>}aRzf[>_3#]?jep^'J7-IwGIGQH[QZpZj*;=}e+IXzlsCI~RZs^1oR~!$fEX~vl3\T
    jaA!xme\Q$YR",DX;z=_#Q}ZToDv$L2p#}\1#swDj<7A^IR>YJ~\JmnwW55~VI^$j];>xUJs<'$n
    JrWvssV>TkY3UpID{KGzJrcQH>7^lGOpus\w1#'w7Ip'1kKY?Xw-*3$5raJJ_7kP-A7VW>7u~=#2
    A1A$5k52>[+Q+}iJNLlQA[vCi{zi3sBU27P2jYm@ClvI]?~C_]v{*>~!vWujC!?&!}A'tFQx~QlK
    ZvU1}eY;VT75QnMbKCGjinQ?v<!7[zo[@C!s7?}GIs?v_2!@Yk{ul;nX*G~J?AZ!*\psroYBr*Vi
    SE2Zn4V!<<^!zQG_<oEZJI]B;rXvO<Z]2ofv3>O}B,z++U?sxO28K,H!>a2T}!5_v1ivBC+*z{wX
    [TV<BC+UP?wJx{*7OMe_&3Dx\Ao{_$C'21B]Jf6-lTWmGADr>WXb\uJn*\iT3D5}1C_[t[_}R?]k
    W1>pBYa_2'_u=eEYDnVZG^WH>$-7Gn$<mK-JX^OpH'U5aUxY=Vrj,n,lTOqE5=;z\\oN@=wVjYJZ
    ^AoY'CmA{z-BY,xw2ElI#-Z{<5DrZo3T=+JJLxQ$;*IQ?JV>CvGH$'_zG@X*H\u<z__^{VRE{[KX
    D''Ie$jO2Ry(^;Ie1$,ntXBsY[E]3tR2EW17*2<sw*[!v;(f#YX'#-sk+s+2[2EY^Ez\z7uVV<DH
    1aUljQ{k>U_;VUZrE[QnUn=[VZ-KY,5V1=p5]ICr]][v'l}7FV^C!&jzZYV=T@[x#kZp}'uneUnX
    ;JDBEro_[T}[aQBB~OI7O1GzUGoj_2H=TO,nZIXAz#pT@QQj^]I>jA4U'n<r*X[-pu}EDG'V^''m
    x]2k=5Ui<x#Te7EOneTK$#X!}!R@G?Z<$iJvJ$KwXz}^371!+o-r<+$vri*pB5]*k\~-\>ns*AB,
    Y5}ve{[+^!^E*{ZAsn5te=C?3<pZA*-rw<T$?Y{]Ux;mrR}D&$XGC(D_vB_*awM/uz+2!>Bp+z{A
    bz$O*O@1{@$GXA=7TC=}X#['m=U>nl]r,~R+>x7GkG'IV,C1!=3mHaXp,v-Cx^JmK-[^OU<'QOz=
    nI*]DO*$Z@\m#EnKmNvB3{ul}GUs+IeEAIKvH-3NNVKuG1j*'soVavBAEEX}-iw<AWzuDOr'!lX1
    kR5]rlT1i:IWAo9^Uv@-rO7=JoZ,7}R}e<
`endprotected

     
  // wire declarations for all parameters used in parameter checks

  wire [31:0] constraints_mode = Constraints_Mode;
  wire [31:0] controller_side = CONTROLLER_SIDE;
  wire [31:0] row_addr_width = ROW_ADDR_WIDTH;
  wire [31:0] data_width = DATA_BUS_WIDTH;
  wire [31:0] dm_width = ZI_INT_DM_WIDTH;
  wire [31:0] perform_dll_tracking = DLL_TRACKING_ENABLE;
  wire [31:0] tras_value = TRAS;
  wire [31:0] trcd_value = TRCD;
  wire [31:0] trp_value = TRP;
  wire [31:0] trrd_value = TRRD;
  wire [31:0] tccd_value = TCCD;
  wire [31:0] trtw_value = TRTW;
  wire [31:0] twtr_value = TWTR;
  wire [31:0] twr_value = TWR;
  wire [31:0] trfc_value = TRFC;
  wire [31:0] txsnr_value = TXSNR;
  wire [31:0] txsrd_value = TXSRD;
  wire [31:0] tmrd_value = TMRD;
  wire [31:0] txp_value = TXP;
  wire [31:0] txard_value = TXARD;
 
  // wire declarations for all checker firings used as arguments for the 
  // fire_fire signal of the fire checkers

  wire dll_not_reset_fire;
  wire mrs_before_precharge_fire;
  wire autoref_before_precharge_fire;
  wire selfref_before_precharge_fire;
  wire insuff_auto_refresh_before_activation_fire;
  wire modereg_not_set_before_active_fire;
  wire cas_latency_invalid_fire;
  wire additive_latency_invalid_fire;
  wire tRRD_violation_fire;
  wire incorrect_command_before_mrs_fire;
  wire tdll_violation_after_dll_reset_fire;
  wire cas_latency_invalid_bypass_fire;
  wire additive_latency_invalid_bypass_fire;


  wire emrs_before_precharge_fire;
  wire emrs_3_before_emrs_2_fire;
  wire emrs_before_emrs_3_fire;
  wire sequential_activation_violation_fire;
 
  // these are used as check enables for corresponding violations and the
  // checker will fire when this is high, indicating some illegal behavior
 
  assign mrs_during_non_precharge = (z_mode_reg_set_cmd &&
                                  (all_banks_in_precharge !== 1'b1));

  assign emrs_during_non_precharge = (ZI_DDR2_SDRAM_2_0 === 1 &&
				     (z_ex_mode_reg_set_cmd ||
				    z_ex_mode_reg_2_set_cmd ||
				    z_ex_mode_reg_3_set_cmd) &&
				   (all_banks_in_precharge !== 1'b1));
 
  assign auto_during_non_precharge = (z_cbr_auto_refresh_cmd &&
                                   (all_banks_in_precharge !== 1'b1));
 
  assign selfref_during_non_precharge = (z_enter_self_refresh_cmd &&
                                      (all_banks_in_precharge !== 1'b1));
 
  assign insufficient_autorefs_before_active = (z_activate_cmd &&
                                          (auto_refresh_cmd_ctr < 2'b10) &&
					  (first_activation_command === 1'b0));
 
  assign modereg_not_set_before_active = (z_activate_cmd &&
                                       (mode_reg_set !== 1'b1));
 
  assign dll_not_reset_before_active = (z_activate_cmd && dll_enabled === 1'b1
                                     && (dll_reset !== 1'b1));

  assign emrs_2_not_issued_before_emrs_3 = (ZI_DDR2_SDRAM_2_0 === 1 &&
					    z_ex_mode_reg_3_set_cmd && 
					  emrs_2_cmd_issued === 1'b0);

  assign emrs_3_not_issued_before_emrs = (ZI_DDR2_SDRAM_2_0 === 1 &&
					 z_ex_mode_reg_set_cmd && 
                                        a[0] === 1'b0 && 
                                        emrs_3_cmd_issued === 1'b0);

  // Seq ACT restriction firing

  assign sequential_activation_violation = ((sum_of_acts_over_last_window +
                                          z_activate_cmd) > 8'd4);


  // cas latency values supported are 2, 3, 4 and 5. these are programmed 
  // during MRS and stored in bits 4 to 6 of mode register. note that the 
  // encoding of 111 on these lines correspond to cas latency of 5.
  
  //  cas_latency_invalid redefined

  assign cas_latency_invalid = (ZI_DDR2_SDRAM_2_0 === 1) ? 
                             (z_activate_cmd && (mode_register[6:4] !== 3'b010 
			      && mode_register[6:4] !== 3'b011 &&
			      mode_register[6:4] !== 3'b100 && 
			      mode_register[6:4] !== 3'b101 &&
                              mode_register[6:4] !== 3'b110)) : 
                             (z_activate_cmd && (mode_register[6:4] !== 3'b010 
			      && mode_register[6:4] !== 3'b011 &&
			      mode_register[6:4] !== 3'b100 && 
			      mode_register[6:4] !== 3'b111));

  assign cas_latency_invalid_bypass = (ZI_DDR2_SDRAM_2_0 === 1) ?
                       (z_activate_cmd && (mode_register_in[6:4] !== 3'b010
                        && mode_register_in[6:4] !== 3'b011 &&
                        mode_register_in[6:4] !== 3'b100 &&
                        mode_register_in[6:4] !== 3'b101 &&
                        mode_register_in[6:4] !== 3'b110 )) :
                        (z_activate_cmd && (mode_register_in[6:4] !== 3'b010
                        && mode_register_in[6:4] !== 3'b011 &&
                        mode_register_in[6:4] !== 3'b100 &&
                        mode_register_in[6:4] !== 3'b111));


 //15DEC06

  wire tCKE_violation = !( (|cke_pipe[QVL_TCKE-1:0] == 1'b0) || (&cke_pipe[QVL_TCKE-1:0] == 1'b1) ) && 
                             (cke !== cke_pipe[0]);

  // additive latency values supported are 0, 1 and 2. this is programmed
  // into bits 3 to 5 of extended mode register during EMRS command.

  // additive_latency_invalid redefined to include AL = 3 & 4
 
  assign additive_latency_invalid = (ZI_DDR2_SDRAM_2_0 === 1) ?
                                  (z_activate_cmd && (ex_mode_register[5:3]
				   !== 3'd0 && ex_mode_register[5:3] !== 3'd1 
				   && ex_mode_register[5:3] !== 3'd2 &&
				   ex_mode_register[5:3] !== 3'd3 &&
				   ex_mode_register[5:3] !== 3'd4)) :
                                  (z_activate_cmd && (ex_mode_register[5:3]
				   !== 3'd0 && ex_mode_register[5:3] !== 3'd1 
				   && ex_mode_register[5:3] !== 3'd2));

  assign additive_latency_invalid_bypass = (ZI_DDR2_SDRAM_2_0 === 1) ?
                              (z_activate_cmd && (ex_mode_register_in[5:3]
                               !== 3'd0 && ex_mode_register_in[5:3] !== 3'd1
                               && ex_mode_register_in[5:3] !== 3'd2 &&
                               ex_mode_register_in[5:3] !== 3'd3 &&
                               ex_mode_register_in[5:3] !== 3'd4)) :
                               (z_activate_cmd && (ex_mode_register_in[5:3]
                               !== 3'd0 && ex_mode_register_in[5:3] !== 3'd1
                               && ex_mode_register_in[5:3] !== 3'd2));

  // Prior to MRS, the only valid commands are NOP, Deselect and Precharge

  assign illegal_cmd_before_mrs = (command !== 6'b110010  &&
                                 command !== 6'b110111 && cke === 1'b1 &&
                                 command[3] !== 1'b1 && r_cke === 1'b1 &&
                                 command !== 6'b110000 &&
                                 mode_reg_set !== 1'b1);

  assign mrs_programmed_correctly = (additive_latency_invalid === 1'b0 &&
                                   cas_latency_invalid === 1'b0);

  assign mrs_programmed_correctly_bypass = 
				   (additive_latency_invalid_bypass === 1'b0 
                                   && cas_latency_invalid_bypass === 1'b0);


  // Minimum interval between DLL reset and first read command should 
  // be 200 clock cycles

  assign tdll_reset_violation = (first_read_command == 1'b0 && (z_read_cmd ||
			       z_read_auto_precharge_cmd) &&
			       dll_reset_to_first_read_counter > 0);

  wire write_burst_0;
  wire write_burst_1;
  wire write_burst_2;
  wire write_burst_3;
  wire write_burst_4;
  wire write_burst_5;
  wire write_burst_6;
  wire write_burst_7;

  wire write_burst = (write_burst_0 || write_burst_1 || write_burst_2 ||
		      write_burst_3 || write_burst_4 || write_burst_5 ||
		      write_burst_6 || write_burst_7);


  // Statistics Block

  reg [63:0] multiple_banks_open_count;
  reg [63:0] max_banks_simultaneously_open;
  reg [63:0] cbr_refresh_commands_count;
  reg [63:0] all_bank_precharges_count;
  reg [63:0] mrs_prog_interleaved_count;
  reg [63:0] mrs_prog_sequential_count;
  reg [63:0] data_accesses_count;
  reg [63:0] self_refresh_commands_count;
  reg [63:0] pwrdn_commands_count;
  reg [63:0] nop_commands_count;
  reg [63:0] deselect_commands_count;

  reg r_bank_0_status;
  reg r_bank_1_status;
  reg r_bank_2_status;
  reg r_bank_3_status;
  reg r_bank_4_status;
  reg r_bank_5_status;
  reg r_bank_6_status;
  reg r_bank_7_status;
  reg [5:0] r_command;
  reg [5:0] rr_command;

  wire posted_write_0; // current cycle in bank 0 is a posted write
  wire posted_read_0;  // current cycle in bank 0 is a posted read
  wire posted_write_1;
  wire posted_read_1;
  wire posted_write_2;
  wire posted_read_2;
  wire posted_write_3;
  wire posted_read_3;
  wire posted_write_4;
  wire posted_read_4;
  wire posted_write_5;
  wire posted_read_5;
  wire posted_write_6;
  wire posted_read_6;
  wire posted_write_7;
  wire posted_read_7;

  wire z_bank_0_active = (r_bank_0_status === 1'b0 && bank_0_status === 1'b1);
  wire z_bank_1_active = (r_bank_1_status === 1'b0 && bank_1_status === 1'b1);
  wire z_bank_2_active = (r_bank_2_status === 1'b0 && bank_2_status === 1'b1);
  wire z_bank_3_active = (r_bank_3_status === 1'b0 && bank_3_status === 1'b1);
  wire z_bank_4_active = (r_bank_4_status === 1'b0 && bank_4_status === 1'b1);
  wire z_bank_5_active = (r_bank_5_status === 1'b0 && bank_5_status === 1'b1);
  wire z_bank_6_active = (r_bank_6_status === 1'b0 && bank_6_status === 1'b1);
  wire z_bank_7_active = (r_bank_7_status === 1'b0 && bank_7_status === 1'b1);

  wire collect_stats;

`protected

    MTI!#~=<~_*7vIinasR;]HjzzU$v$z=wJ';7T=;7RHskUjn^2=Vji6lIO~};EX[LVQj@J'>ZQpn1
    ?>2+i\i,:E+\vMYDn~yIZ-z~s\lAER)*7QK51im1nInEs7A+57Ipn{erlv},JoIf~l2@[a{jG1=x
    Bk*A$u~'}Ywuziu*kezz-[W2IrKQw{B}NiTv^<Te]=la$ARQ<irkII~w?OlI']lHYI{K!u5KrW*I
    +h};Hna1*Ia<C~}XG3Geeu=;'$.;$X@O\<pJYZ@nC"I>ARYsm1npo@QXKJ~5wa*T-[Q}^@Y~^YI?
    Xzil5RVn,>wwV=Q}#p]{Rmx~OiY^eUpW\aO-~G-^[<5QC'aw*7-+;!GZ~r^,27\5uZH+jRecRjsj
    2,V[#jn>swl<DX1j'x_*A'ex+VnAYE[;pXAp~I!3Qz+,j~$-ER!jCQ_B8uXji{_+<N=cV=R'fmo-
    ;Nq=zrY#EzErIC3Ka*^[!u!BOE}QwH5[AO;N:H\5[]aroz_*{=T\27U@!Qd~zJ]9BrUw,Q^xoZvH
    kTzjx"^>eW#1[=~7Jr8@9^*n[U<}#^#vl<Gen^rU$Q[},w'$CEsT@HzW1KX>J4uzww,oX*T]>jYZ
    KnTYI3IUREXwY[xCl^C^e7/oBX~\j'\)'@Jn_u,[d[e?Q@T1U=q6G#_[i_ez>$j=EQl*EBr?>o[[
    7iI~_O5Hk5As;GTxsnX]}E]\[xRvx,'Q#[Ae4[5JEs-VlIG3E'-7#P/Gl}YB{]kRHn-lkO5{X=OG
    5ep1mx-]u=!rsDX1I_Ilm-R-rQRAI7lB=k2RG?,kAVr^!Xz=nEo$5oej[QnDieEMo1mU_-oOQ;UK
    ^>QGZS8Vr-vuUBH
`endprotected
  assign num_banks_active = (ZI_DDR2_SDRAM_2_0 === 1) ?
                                bank_0_status + bank_1_status + bank_2_status +
                                bank_3_status + bank_4_status + bank_5_status +
                                bank_6_status + bank_7_status :
                                bank_0_status + bank_1_status + bank_2_status +
                                bank_3_status;

`protected

    MTI!#R2\;D\nHW=oAowH+?sTo}7Jwbm{$@<r[iFB-bN>=D[;]ar=nll=+]i2jB"*kAO!1E7l?2;>
    U3_?RSBxm5}^jaD=]{Q8"l3+VBOQA+^KH,~H[s@]oV<u\${_iuO,[Z]J2B1ZnD{Ruu<e[V'2^r1Q
    w<I3C\\B-HwW'^~p'{jkryBI@Y4{DZWp~]_Rkas[$BWLxOToO*7}IX1$7A\n$*V]DaeIVIek(9!H
    2Qs-]$lReGvnpT3IwQ5evuqaT2~!$\~*aZV*a@I/nvX~\^e];1l+\O-1_U<IUs$x}#]>e2l5pEQx
    UEeEvo5;mOCv>wx31w<[_@nG[3-rA=;On=Ci1[A~B3$,oQp1L^*5GpD#@KUzwKn>~IWn~m]*W$#3
    '9i}J7DH@A2[v3V(#GB^1DJ>}Z9#5W]ToY-7EZB,D]U:!OTv\-n@_TKDJwG+^TD>_Y}nQ-<7svx<
    p*;\moIXl5+\xo='}!v#Y?@_sB*E{G]E~$AEW7>si<+XC;}O<1Eih#z;ovn5<|VKECeHlsXz#C\i
    GCxO]E+<Y}{N,s-+2EA'UBwa,?TGBjZ?{B2Y~=5w73j@JGCze#{CX{Z2<{a?L7ka}3''J^+V^7G'
    ;oK<][ZQHLR!^,H'Jv,Rj2av,kB^>Z#DlDiT[rJavGgu|^m1mVs?oCBUOE<JAi_#TEv,~}u=kBl^
    T?X[TB!@Q#|IeXk=ZnRjQQnh?r'@_*uoypi[r31epHA!r|/I$3G-{ArQ?B'E7@>_=CDuY'Kl^w'M
    ^J=[WBYZQJE$-VkrQ~Gu=QjYs}IZ=$ee\>E]'k!>or}r-YC*jOCeBC!v~eApQJCA-RYBNlN=_BIC
    =WI9'ZwZ*m[u-j@lI1$]}GY}2<j{7{7+j%iavi,oZ*yACz;pW{o#UH=4<Ap-:2e7T1mw*>Q?IY'V
    ${rCW-p\>!UZUo'~7^rpO*w~[7@XeQv[u/I=+=J5#2!,sK,[~#
`endprotected

  // End of Stats block

  wire bad_data_chk = ZI_DATA_CHECK_ENABLE;
  wire read_before_write = READ_BEFORE_WRITE_CHECK_ENABLE;

  assign ldq = (ZI_DDR2_SDRAM_2_0 === 1 && DATA_BUS_WIDTH === 16) ? dq : 8'b0;

  assign udq = (ZI_DDR2_SDRAM_2_0 === 1 && DATA_BUS_WIDTH === 16) ? dq >> 8 : 
                                                                    8'b0;


wire [BANK_ADDR_WIDTH-1:0] bank_num_b0 = (BANK_ADDR_WIDTH == 2)? 2'b00 : 3'b000;
wire [BANK_ADDR_WIDTH-1:0] bank_num_b1 = (BANK_ADDR_WIDTH == 2)? 2'b01 : 3'b001;
wire [BANK_ADDR_WIDTH-1:0] bank_num_b2 = (BANK_ADDR_WIDTH == 2)? 2'b10 : 3'b010;
wire [BANK_ADDR_WIDTH-1:0] bank_num_b3 = (BANK_ADDR_WIDTH == 2)? 2'b11 : 3'b011;


  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
	    ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
	    READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
	    ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
	    ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
		     BANK0
			   (.clock(ck),
			    .clock_n(ck_n),
			    .areset(areset),
			    .reset(reset),
			    .command(command),
			    .address(a),
			    .bank_addr(ba),
			    .bank_num(bank_num_b0),
			    .data_mask(dm_rdqs),
			    .data(dq),
			    .dqs(dqs),
			    .posted_read(posted_read_0),
			    .posted_write(posted_write_0),
			    .bank_status(bank_0_status),
			    .cas_latency(cas_latency_value),
			    .additive_latency(additive_latency),
			    .burst_type(burst_type),
			    .write_burst_in_progress(write_burst_0),
			    .bad_data_chk(bad_data_chk),
			    .read_before_write_chk(read_before_write),
			    .burst_length_programmed(burst_length_programmed),
			    .tWR_programmed(tWR_programmed),
			    .slow_exit(slow_exit),
			    .ldq(ldq),
			    .ldqs(ldqs),
			    .ldm(ldm),
			    .udq(udq),
			    .udqs(udqs),
			    .udm(udm),
			    .rdqs_enable(rdqs_enable),
		            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
			   );

  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
	    ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
            READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
            ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
            ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
	              BANK1
			   (.clock(ck),
			    .clock_n(ck_n),
                            .areset(areset),
                            .reset(reset),
                            .command(command),
                            .address(a),
                            .bank_addr(ba),
                            .bank_num(bank_num_b1),
                            .data_mask(dm_rdqs),
                            .data(dq),
                            .dqs(dqs),
                            .posted_read(posted_read_1),
                            .posted_write(posted_write_1),
                            .bank_status(bank_1_status),
                            .cas_latency(cas_latency_value),
                            .additive_latency(additive_latency),
                            .burst_type(burst_type),
			    .write_burst_in_progress(write_burst_1),
			    .bad_data_chk(bad_data_chk),
			    .read_before_write_chk(read_before_write),
                            .burst_length_programmed(burst_length_programmed),
                            .tWR_programmed(tWR_programmed),
			    .slow_exit(slow_exit),
                            .ldq(ldq),
                            .ldqs(ldqs), 
                            .ldm(ldm), 
                            .udq(udq), 
                            .udqs(udqs), 
                            .udm(udm),
                            .rdqs_enable(rdqs_enable),
                            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
                           );

  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
	    ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
            READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
            ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
            ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
	             BANK2
                           (.clock(ck),
			    .clock_n(ck_n),
                            .areset(areset),
                            .reset(reset),
                            .command(command),
                            .address(a),
                            .bank_addr(ba),
                            .bank_num(bank_num_b2),
                            .data_mask(dm_rdqs),
                            .data(dq),
                            .dqs(dqs),
                            .posted_read(posted_read_2),
                            .posted_write(posted_write_2),
                            .bank_status(bank_2_status),
                            .cas_latency(cas_latency_value),
                            .additive_latency(additive_latency),
                            .burst_type(burst_type),
			    .write_burst_in_progress(write_burst_2),
			    .bad_data_chk(bad_data_chk),
			    .read_before_write_chk(read_before_write),
                            .burst_length_programmed(burst_length_programmed),
                            .tWR_programmed(tWR_programmed),
			    .slow_exit(slow_exit),
                            .ldq(ldq),
                            .ldqs(ldqs), 
                            .ldm(ldm), 
                            .udq(udq), 
                            .udqs(udqs), 
                            .udm(udm),
                            .rdqs_enable(rdqs_enable),
                            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
                           );

  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
	    ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
            READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
            ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
            ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
	             BANK3
                           (.clock(ck),
			    .clock_n(ck_n),
                            .areset(areset),
                            .reset(reset),
                            .command(command),
                            .address(a),
                            .bank_addr(ba),
                            .bank_num(bank_num_b3),
                            .data_mask(dm_rdqs),
                            .data(dq),
                            .dqs(dqs),
                            .posted_read(posted_read_3),
                            .posted_write(posted_write_3),
                            .bank_status(bank_3_status),
                            .cas_latency(cas_latency_value),
                            .additive_latency(additive_latency),
                            .burst_type(burst_type),
			    .write_burst_in_progress(write_burst_3),
			    .bad_data_chk(bad_data_chk),
			    .read_before_write_chk(read_before_write),
                            .burst_length_programmed(burst_length_programmed),
                            .tWR_programmed(tWR_programmed),
			    .slow_exit(slow_exit),
                            .ldq(ldq),
                            .ldqs(ldqs), 
                            .ldm(ldm), 
                            .udq(udq), 
                            .udqs(udqs), 
                            .udm(udm),
                            .rdqs_enable(rdqs_enable),
                            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
                           );

generate

 if( BANK_ADDR_WIDTH == 3) begin:BANKS_8_MODE

  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
            ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
            READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
            ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
            ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
	             BANK4
                           (.clock(ck),
                            .clock_n(ck_n),
                            .areset(areset),
                            .reset(reset),
                            .command(command),
                            .address(a),
                            .bank_addr(ba),
                            .bank_num(3'b100),
                            .data_mask(dm_rdqs),
                            .data(dq),
                            .dqs(dqs),
                            .posted_read(posted_read_4),
                            .posted_write(posted_write_4),
                            .bank_status(bank_4_status),
                            .cas_latency(cas_latency_value),
                            .additive_latency(additive_latency),
                            .burst_type(burst_type),
                            .write_burst_in_progress(write_burst_4),
                            .bad_data_chk(bad_data_chk),
                            .read_before_write_chk(read_before_write),
                            .burst_length_programmed(burst_length_programmed),
                            .tWR_programmed(tWR_programmed),
                            .slow_exit(slow_exit),
                            .ldq(ldq),
                            .ldqs(ldqs), 
                            .ldm(ldm), 
                            .udq(udq), 
                            .udqs(udqs), 
                            .udm(udm),
                            .rdqs_enable(rdqs_enable),
                            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
                           );

  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
            ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
            READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
            ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
            ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
	             BANK5
                           (.clock(ck),
                            .clock_n(ck_n),
                            .areset(areset),
                            .reset(reset),
                            .command(command),
                            .address(a),
                            .bank_addr(ba),
                            .bank_num(3'b101),
                            .data_mask(dm_rdqs),
                            .data(dq),
                            .dqs(dqs),
                            .posted_read(posted_read_5),
                            .posted_write(posted_write_5),
                            .bank_status(bank_5_status),
                            .cas_latency(cas_latency_value),
                            .additive_latency(additive_latency),
                            .burst_type(burst_type),
                            .write_burst_in_progress(write_burst_5),
                            .bad_data_chk(bad_data_chk),
                            .read_before_write_chk(read_before_write),
                            .burst_length_programmed(burst_length_programmed),
                            .tWR_programmed(tWR_programmed),
                            .slow_exit(slow_exit),
                            .ldq(ldq),
                            .ldqs(ldqs), 
                            .ldm(ldm), 
                            .udq(udq), 
                            .udqs(udqs), 
                            .udm(udm),
                            .rdqs_enable(rdqs_enable),
                            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
                           );

  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
            ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
            READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
            ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
            ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
	             BANK6
                           (.clock(ck),
                            .clock_n(ck_n),
                            .areset(areset),
                            .reset(reset),
                            .command(command),
                            .address(a),
                            .bank_addr(ba),
                            .bank_num(3'b110),
                            .data_mask(dm_rdqs),
                            .data(dq),
                            .dqs(dqs),
                            .posted_read(posted_read_6),
                            .posted_write(posted_write_6),
                            .bank_status(bank_6_status),
                            .cas_latency(cas_latency_value),
                            .additive_latency(additive_latency),
                            .burst_type(burst_type),
                            .write_burst_in_progress(write_burst_6),
                            .bad_data_chk(bad_data_chk),
                            .read_before_write_chk(read_before_write),
                            .burst_length_programmed(burst_length_programmed),
                            .tWR_programmed(tWR_programmed),
                            .slow_exit(slow_exit),
                            .ldq(ldq),
                            .ldqs(ldqs), 
                            .ldm(ldm), 
                            .udq(udq), 
                            .udqs(udqs), 
                            .udm(udm),
                            .rdqs_enable(rdqs_enable),
                            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
                           );

  qvl_ddr2_sdram_bank_module #(Constraints_Mode,CONTROLLER_SIDE,
            ROW_ADDR_WIDTH,DATA_BUS_WIDTH,ZI_INT_DM_WIDTH,
            DLL_TRACKING_ENABLE,TRAS,TRCD,TRP,TRRD,TCCD,TRTW,TWTR,
            TWR,TRFC,TXSNR,TXSRD,TMRD,AUTOPRECHARGE_ENABLE_ADDRESS_BIT,
            READ_BEFORE_WRITE_CHECK_ENABLE,TXP,TXARD,BANK_ADDR_WIDTH,
            ENABLE_PRECHARGE_TO_IDLE_BANK,BYPASS_INIT,ZI_DDR2_SDRAM_2_0,
            ZI_DATA_CHECK_ENABLE,ZI_DM_RDQS_WIDTH)
	            BANK7
                           (.clock(ck),
                            .clock_n(ck_n),
                            .areset(areset),
                            .reset(reset),
                            .command(command),
                            .address(a),
                            .bank_addr(ba),
                            .bank_num(3'b111),
                            .data_mask(dm_rdqs),
                            .data(dq),
                            .dqs(dqs),
                            .posted_read(posted_read_7),
                            .posted_write(posted_write_7),
                            .bank_status(bank_7_status),
                            .cas_latency(cas_latency_value),
                            .additive_latency(additive_latency),
                            .burst_type(burst_type),
                            .write_burst_in_progress(write_burst_7),
                            .bad_data_chk(bad_data_chk),
                            .read_before_write_chk(read_before_write),
                            .burst_length_programmed(burst_length_programmed),
                            .tWR_programmed(tWR_programmed),
                            .slow_exit(slow_exit),
                            .ldq(ldq),
                            .ldqs(ldqs), 
                            .ldm(ldm), 
                            .udq(udq), 
                            .udqs(udqs), 
                            .udm(udm),
                            .rdqs_enable(rdqs_enable),
                            .diff_strobe_enable(diff_strobe_enable),
			    .rdqs(rdqs)
                           );
end
endgenerate


`include "qvl_ddr2_sdram_2_0_monitor_assertions.inc"
`include "qvl_ddr2_sdram_2_0_monitor_cover.inc"

`ifdef ZI_INLINED_PSL
`include "0in_ac_inline_for_mod_zi_cw_ddr2_sdram_2_0_monitor.inc"
`endif
`ifdef ZI_INLINED_CHX
`include "zi_cw_ddr2_sdram_2_0_monitor.zi_chx.inc"
`else
`ifdef ZI_INLINED_CHX_zi_cw_ddr2_sdram_2_0_monitor
`include "zi_cw_ddr2_sdram_2_0_monitor.zi_chx.inc"
`endif
`endif

`qvlendmodule // qvl_ddr2_sdram_2_0_logic
